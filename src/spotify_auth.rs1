use axum::{
    routing::get,
    Router,
    extract::Query,
    response::IntoResponse,
    http::StatusCode,
};
use serde::Deserialize;
use std::sync::{Arc, Mutex};
use tokio::sync::oneshot;
use std::time::Duration;

#[derive(Deserialize)]
struct AuthCode {
    code: String,
}

pub async fn authenticate_spotify(
    client_id: String,
    client_secret: String,
) -> Result<rspotify::client::SpotifyBuilder, Box<dyn std::error::Error>> {
    // Channels
    let (auth_tx, auth_rx) = oneshot::channel();
    let (shutdown_tx, _) = tokio::sync::broadcast::channel(1);
    
    let auth_tx = Arc::new(Mutex::new(Some(auth_tx)));
    let shutdown_tx_clone = shutdown_tx.clone();
    
    // Start OAuth server
    let auth_tx_clone = auth_tx.clone();
    tokio::spawn(async move {
        let app = Router::new()
            .route("/callback", get(handle_callback))
            .with_state(auth_tx_clone);
        
        let listener = tokio::net::TcpListener::bind("127.0.0.1:8888")
            .await
            .expect("Failed to bind to port 8888");
        
        println!("OAuth server listening on http://127.0.0.1:8888");
        
        let mut shutdown_rx = shutdown_tx_clone.subscribe();
        axum::serve(listener, app)
            .with_graceful_shutdown(async move {
                let _ = shutdown_rx.recv().await;
                println!("Shutting down OAuth server");
            })
            .await
            .unwrap();
    });
    
    // Step 1: Build OAuth flow
    let oauth = rspotify::oauth2::AuthorizationCodeFlow::new(
        client_id,
        client_secret,
        "http://localhost:8888/callback".to_string(),
    );
    
    // Step 2: Get auth URL
    let auth_url = oauth.get_authorize_url(false, &[
        "playlist-modify-public",
        "playlist-modify-private",
        "user-read-private",
    ])?;
    
    println!("Visit this URL to authorize: {}", auth_url);
    
    // Step 3: Wait for callback (with timeout)
    let code = match tokio::time::timeout(Duration::from_secs(300), auth_rx).await {
        Ok(Ok(code)) => code,
        Ok(Err(_)) => return Err("Failed to receive auth code".into()),
        Err(_) => return Err("Authorization timeout (5 minutes)".into()),
    };
    
    println!("Received authorization code");
    
    // Step 4: Shutdown server
    let _ = shutdown_tx.send(());
    
    // Step 5: Exchange code for token
    oauth.request_access_token(&code).await?;
    println!("Successfully exchanged code for token");
    
    // Step 6: Return builder
    let spotify_builder = rspotify::client::SpotifyBuilder::default()
        .auth(oauth);
    
    Ok(spotify_builder)
}

async fn handle_callback(
    Query(params): Query<AuthCode>,
    axum::extract::State(tx): axum::extract::State<Arc<Mutex<Option<oneshot::Sender<String>>>>>,
) -> impl IntoResponse {
    if let Ok(mut sender) = tx.lock() {
        if let Some(sender) = sender.take() {
            let _ = sender.send(params.code.clone());
            return (StatusCode::OK, "Authorization successful! You can close this window.");
        }
    }
    (StatusCode::BAD_REQUEST, "Already authorized")
}
